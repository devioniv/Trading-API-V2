import numpy as np
import pandas as pd
import pandas_ta as ta

# This file will contain the consolidated trendline breakout strategy.

# --- IBKR API Integration Notes ---
# To use this strategy with the Interactive Brokers API, you would typically:
# 1. Create a wrapper class for the IBKR API (inheriting from EWrapper).
# 2. In your wrapper, connect to TWS/Gateway and subscribe to historical data or
#    real-time bars for your desired instrument.
# 3. Instantiate the `TrendlineStrategy` class: `strategy = TrendlineStrategy(...)`.
# 4. For each bar of data you receive from IBKR (in methods like `historicalData`
#    or `realtimeBar`), call the `strategy.on_bar(bar.high, bar.low, bar.close)` method.
# 5. Check the signal returned by `on_bar` and place orders accordingly using `EClient.placeOrder`.
#    - Signal 1 (Enter Long): Place a BUY order.
#    - Signal -1 (Enter Short): Place a SELL order.
#    - Signal 2 (Exit): Close the current position (e.g., by placing an opposite order).
#
# The example at the end of this file (`if __name__ == '__main__':`) simulates this
# process with data from a CSV file. You can adapt it for live trading.
# ---

def check_trend_line(support: bool, pivot: int, slope: float, y: np.array):
    """
    Computes the error of a trendline and checks its validity.
    A support line is invalid if it is above any of the data points.
    A resistance line is invalid if it is below any of the data points.
    """
    intercept = y[pivot] - slope * pivot
    line_vals = slope * np.arange(len(y)) + intercept
    diffs = line_vals - y
    if support and diffs.max() > 1e-5:
        return -1.0
    elif not support and diffs.min() < -1e-5:
        return -1.0
    return (diffs ** 2.0).sum()


def optimize_slope(support: bool, pivot:int , init_slope: float, y: np.array):
    """
    Optimizes the slope of a trendline to minimize the error.
    """
    slope_unit = (y.max() - y.min()) / len(y) if len(y) > 0 else 0.01
    opt_step = 1.0
    min_step = 0.0001
    curr_step = opt_step
    
    best_slope = init_slope
    best_err = check_trend_line(support, pivot, init_slope, y)
    if best_err < 0.0:
        best_err = check_trend_line(support, pivot, 0.0, y)
        if best_err < 0.0:
            return (init_slope, y[pivot] - init_slope * pivot)

    get_derivative = True
    while curr_step > min_step:
        if get_derivative:
            slope_change = best_slope + slope_unit * min_step
            test_err = check_trend_line(support, pivot, slope_change, y)
            if test_err < 0.0:
                slope_change = best_slope - slope_unit * min_step
                test_err = check_trend_line(support, pivot, slope_change, y)
                if test_err < 0.0:
                    break
                derivative = best_err - test_err
            else:
                derivative = test_err - best_err
            get_derivative = False

        if derivative > 0.0:
            test_slope = best_slope - slope_unit * curr_step
        else:
            test_slope = best_slope + slope_unit * curr_step
        
        test_err = check_trend_line(support, pivot, test_slope, y)
        if test_err < 0 or test_err >= best_err:
            curr_step *= 0.5
        else:
            best_err = test_err
            best_slope = test_slope
            get_derivative = True
            
    return (best_slope, y[pivot] - best_slope * pivot)


def fit_trendlines_single(data: np.array):
    """
    Fits support and resistance trendlines to a single data series.
    """
    x = np.arange(len(data))
    coefs = np.polyfit(x, data, 1)
    line_points = coefs[0] * x + coefs[1]
    upper_pivot = (data - line_points).argmax()
    lower_pivot = (data - line_points).argmin()
    support_coefs = optimize_slope(True, lower_pivot, coefs[0], data)
    resist_coefs = optimize_slope(False, upper_pivot, coefs[0], data)
    return (support_coefs, resist_coefs)


class TrendlineStrategy:
    """
    Encapsulates the trendline breakout trading strategy with trade management.
    """
    def __init__(self, lookback_period=72, atr_lookback=14, tp_mult=3.0, sl_mult=3.0):
        self.lookback_period = lookback_period
        self.atr_lookback = atr_lookback
        self.tp_mult = tp_mult
        self.sl_mult = sl_mult

        self.close_prices = []
        self.high_prices = []
        self.low_prices = []

        self._reset_trade_state()

    def _reset_trade_state(self):
        self.in_trade = False
        self.position = 0
        self.trade_entry_price = 0
        self.stop_loss_price = 0
        self.take_profit_price = 0

    def on_bar(self, high, low, close):
        """
        Processes a new bar of data and returns a trading signal.
        :return: 1 (entry long), -1 (entry short), 2 (exit), 0 (no action).
        """
        self.high_prices.append(high)
        self.low_prices.append(low)
        self.close_prices.append(close)

        max_len = self.lookback_period + 1
        if len(self.close_prices) > max_len:
            self.close_prices.pop(0)
            self.high_prices.pop(0)
            self.low_prices.pop(0)

        # --- Exit Logic ---
        if self.in_trade:
            if self.position == 1 and (low <= self.stop_loss_price or high >= self.take_profit_price):
                self._reset_trade_state()
                return 2
            elif self.position == -1 and (high >= self.stop_loss_price or low <= self.take_profit_price):
                self._reset_trade_state()
                return 2
        
        # --- Entry Logic ---
        if len(self.close_prices) < self.lookback_period:
            return 0

        window = np.array(self.close_prices[-self.lookback_period-1:-1])
        try:
            support_coefs, resist_coefs = fit_trendlines_single(window)
        except Exception:
            return 0

        s_val = support_coefs[1] + self.lookback_period * support_coefs[0]
        r_val = resist_coefs[1] + self.lookback_period * resist_coefs[0]

        if not self.in_trade:
            atr = self._calculate_atr()
            if atr is None:
                return 0 # Not enough data for ATR

            if close > r_val: # Long entry
                self.in_trade = True
                self.position = 1
                self.trade_entry_price = close
                self.stop_loss_price = close - atr * self.sl_mult
                self.take_profit_price = close + atr * self.tp_mult
                return 1
            elif close < s_val: # Short entry
                self.in_trade = True
                self.position = -1
                self.trade_entry_price = close
                self.stop_loss_price = close + atr * self.sl_mult
                self.take_profit_price = close - atr * self.tp_mult
                return -1
        
        return 0

    def _calculate_atr(self):
        """Calculates the ATR for the current data buffer."""
        if len(self.close_prices) < self.atr_lookback:
            return None
        
        high_series = pd.Series(self.high_prices)
        low_series = pd.Series(self.low_prices)
        close_series = pd.Series(self.close_prices)
        
        atr = ta.atr(high_series, low_series, close_series, length=self.atr_lookback)
        return atr.iloc[-1]


if __name__ == '__main__':
    # --- Example Usage ---
    # This block demonstrates how to use the TrendlineStrategy with historical data.
    # In a live environment, you would replace the data generation/loading part
    # with your data feed from the IBKR API.

    print("--- Trendline Breakout Strategy Example ---")

    # 1. Generate Sample Data
    # We generate dummy data since no CSV file is provided.
    # Replace this with your data loading logic.
    lookback_period_example = 72
    data_points = lookback_period_example + 50  # Enough data for lookback and some trades
    
    print(f"Generating {data_points} bars of sample data...")
    # Generate a sine wave with noise to simulate price action
    x = np.arange(data_points)
    prices = 100 + 5 * np.sin(x * 0.1) + np.random.randn(data_points) * 0.5
    # Force a breakout at the end to generate a signal
    prices[-15:] += 8
    
    data = pd.DataFrame({
        'close': prices,
        'high': prices + 0.5,
        'low': prices - 0.5
    })
    
    # The strategy is designed to work with log-transformed prices
    log_data = np.log(data)

    # 2. Initialize the Strategy
    strategy = TrendlineStrategy(
        lookback_period=lookback_period_example, 
        atr_lookback=14, 
        tp_mult=2.0, 
        sl_mult=2.0
    )
    print("Strategy initialized. Starting simulation...")

    # 3. Simulate Bar-by-Bar Processing
    for i, row in log_data.iterrows():
        signal = strategy.on_bar(row['high'], row['low'], row['close'])
        
        # In a real trading scenario, you would handle order execution here.
        if signal != 0:
            print(f"\n--- Bar {i} ---")
            current_price = np.exp(row['close'])
            if signal == 1:
                print(f"  Action: Enter LONG @ {current_price:.2f}")
                print(f"  SL: {np.exp(strategy.stop_loss_price):.2f}, TP: {np.exp(strategy.take_profit_price):.2f}")
                # TODO: Place your IBKR BUY order here.
            elif signal == -1:
                print(f"  Action: Enter SHORT @ {current_price:.2f}")
                print(f"  SL: {np.exp(strategy.stop_loss_price):.2f}, TP: {np.exp(strategy.take_profit_price):.2f}")
                # TODO: Place your IBKR SELL order here.
            elif signal == 2:
                print(f"  Action: EXIT trade @ {current_price:.2f}")
                # TODO: Place your IBKR order to close the position here.
    
    print("\n--- Simulation Finished ---")
